{"ast":null,"code":"var _classCallCheck = require(\"/Users/maksim/Documents/Worksapce/todo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Gradient = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Gradient() {\n    var _this = this;\n\n    var gradients = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var maxNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var colors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['', ''];\n    var intervals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, Gradient);\n\n    var setColors = function setColors(props) {\n      if (props.length < 2) {\n        throw new Error(\"setGradient should have more than \".concat(props.length, \" color\"));\n      } else {\n        var increment = maxNum / (props.length - 1);\n        var firstGradient = new GradientColor();\n        var lower = 0;\n        var upper = 0 + increment;\n        firstGradient.setGradient(props[0], props[1]);\n        firstGradient.setMidpoint(lower, upper);\n        gradients = [firstGradient];\n        intervals = [{\n          lower: lower,\n          upper: upper\n        }];\n\n        for (var i = 1; i < props.length - 1; i++) {\n          var gradientColor = new GradientColor();\n\n          var _lower = 0 + increment * i;\n\n          var _upper = 0 + increment * (i + 1);\n\n          gradientColor.setGradient(props[i], props[i + 1]);\n          gradientColor.setMidpoint(_lower, _upper);\n          gradients[i] = gradientColor;\n          intervals[i] = {\n            lower: _lower,\n            upper: _upper\n          };\n        }\n\n        colors = props;\n      }\n    };\n\n    this.setGradient = function () {\n      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n        props[_key] = arguments[_key];\n      }\n\n      setColors(props);\n      return _this;\n    };\n\n    this.getArray = function () {\n      var gradientArray = [];\n\n      for (var j = 0; j < intervals.length; j++) {\n        var interval = intervals[j];\n        var start = interval.lower === 0 ? 1 : Math.ceil(interval.lower);\n        var end = interval.upper === maxNum ? interval.upper + 1 : Math.ceil(interval.upper);\n\n        for (var i = start; i < end; i++) {\n          gradientArray.push(gradients[j].getColor(i));\n        }\n      }\n\n      return gradientArray;\n    };\n\n    this.getColor = function (props) {\n      if (isNaN(props)) {\n        throw new TypeError(\"getColor should be a number\");\n      } else if (props <= 0) {\n        throw new TypeError(\"getColor should be greater than \".concat(props));\n      } else {\n        var segment = (maxNum - 0) / gradients.length;\n        var index = Math.min(Math.floor((Math.max(props, 0) - 0) / segment), gradients.length - 1);\n        return gradients[index].getColor(props);\n      }\n    };\n\n    this.setMidpoint = function (maxNumber) {\n      if (!isNaN(maxNumber) && maxNumber >= 0) {\n        maxNum = maxNumber;\n        setColors(colors);\n      } else if (maxNumber <= 0) {\n        throw new RangeError(\"midPoint should be greater than \".concat(maxNumber));\n      } else {\n        throw new RangeError('midPoint should be a number');\n      }\n\n      return _this;\n    };\n  }\n\n  return Gradient;\n}();\n\nvar GradientColor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function GradientColor() {\n    var startColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var endColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var minNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var maxNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n\n    _classCallCheck(this, GradientColor);\n\n    this.setGradient = function (colorStart, colorEnd) {\n      startColor = getHexColor(colorStart);\n      endColor = getHexColor(colorEnd);\n    };\n\n    this.setMidpoint = function (minNumber, maxNumber) {\n      minNum = minNumber;\n      maxNum = maxNumber;\n    };\n\n    this.getColor = function (props) {\n      if (props) {\n        return '#' + generateHex(props, startColor.substring(0, 2), endColor.substring(0, 2)) + generateHex(props, startColor.substring(2, 4), endColor.substring(2, 4)) + generateHex(props, startColor.substring(4, 6), endColor.substring(4, 6));\n      }\n    };\n\n    var generateHex = function generateHex(number, start, end) {\n      if (number < minNum) {\n        number = minNum;\n      } else if (number > maxNum) {\n        number = maxNum;\n      }\n\n      var midPoint = maxNum - minNum;\n      var startBase = parseInt(start, 16);\n      var endBase = parseInt(end, 16);\n      var average = (endBase - startBase) / midPoint;\n      var finalBase = Math.round(average * (number - minNum) + startBase);\n      var balancedFinalBase = finalBase < 16 ? \"0\" + finalBase.toString(16) : finalBase.toString(16);\n      return balancedFinalBase;\n    };\n\n    var getHexColor = function getHexColor(props) {\n      return props.substring(props.length - 6, props.length);\n    };\n  }\n\n  return GradientColor;\n}();\n\nmodule.exports = Gradient;","map":{"version":3,"sources":["/Users/maksim/Documents/Worksapce/todo/node_modules/javascript-color-gradient/src/index.js"],"names":["Gradient","gradients","maxNum","colors","intervals","setColors","props","length","Error","increment","firstGradient","GradientColor","lower","upper","setGradient","setMidpoint","i","gradientColor","getArray","gradientArray","j","interval","start","Math","ceil","end","push","getColor","isNaN","TypeError","segment","index","min","floor","max","maxNumber","RangeError","startColor","endColor","minNum","colorStart","colorEnd","getHexColor","minNumber","generateHex","substring","number","midPoint","startBase","parseInt","endBase","average","finalBase","round","balancedFinalBase","toString","module","exports"],"mappings":"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","sourcesContent":["class Gradient {\r\n    constructor(gradients = '', maxNum = 10, colors = ['', ''], intervals = []) {\r\n\r\n        const setColors = props => {\r\n            if (props.length < 2) {\r\n                throw new Error(`setGradient should have more than ${props.length} color`);\r\n            } else {\r\n                let increment = maxNum / (props.length - 1);\r\n                let firstGradient = new GradientColor();\r\n                let lower = 0;\r\n                let upper = 0 + increment;\r\n                firstGradient.setGradient(props[0], props[1]);\r\n                firstGradient.setMidpoint(lower, upper);\r\n                gradients = [firstGradient];\r\n                intervals = [{\r\n                    lower,\r\n                    upper\r\n                }];\r\n\r\n                for (let i = 1; i < props.length - 1; i++) {\r\n                    let gradientColor = new GradientColor();\r\n                    let lower = 0 + increment * i;\r\n                    let upper = 0 + increment * (i + 1);\r\n                    gradientColor.setGradient(props[i], props[i + 1]);\r\n                    gradientColor.setMidpoint(lower, upper);\r\n                    gradients[i] = gradientColor;\r\n                    intervals[i] = {\r\n                        lower,\r\n                        upper\r\n                    };\r\n                }\r\n                colors = props;\r\n            }\r\n        }\r\n\r\n        this.setGradient = (...props) => {\r\n            setColors(props);\r\n            return this;\r\n        }\r\n\r\n        this.getArray = () => {\r\n            let gradientArray = [];\r\n            for (let j = 0; j < intervals.length; j++) {\r\n                const interval = intervals[j];\r\n                const start = interval.lower === 0 ? 1 : Math.ceil(interval.lower);\r\n                const end = interval.upper === maxNum ? interval.upper + 1 : Math.ceil(interval.upper);\r\n                for (let i = start; i < end; i++) {\r\n                    gradientArray.push(gradients[j].getColor(i))\r\n                }\r\n            }\r\n            return gradientArray;\r\n        }\r\n\r\n        this.getColor = props => {\r\n            if (isNaN(props)) {\r\n                throw new TypeError(`getColor should be a number`);\r\n            } else if (props <= 0) {\r\n                throw new TypeError(`getColor should be greater than ${props}`);\r\n            } else {\r\n                let segment = (maxNum - 0) / (gradients.length);\r\n                let index = Math.min(Math.floor((Math.max(props, 0) - 0) / segment), gradients.length - 1);\r\n                return gradients[index].getColor(props);\r\n            }\r\n        }\r\n\r\n        this.setMidpoint = (maxNumber) => {\r\n            if (!isNaN(maxNumber) && maxNumber >= 0) {\r\n                maxNum = maxNumber;\r\n                setColors(colors);\r\n            } else if (maxNumber <= 0) {\r\n                throw new RangeError(`midPoint should be greater than ${maxNumber}`);\r\n            } else {\r\n                throw new RangeError('midPoint should be a number');\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n}\r\n\r\nclass GradientColor {\r\n    constructor(startColor = '', endColor = '', minNum = 0, maxNum = 10) {\r\n        this.setGradient = (colorStart, colorEnd) => {\r\n            startColor = getHexColor(colorStart);\r\n            endColor = getHexColor(colorEnd);\r\n        }\r\n\r\n        this.setMidpoint = (minNumber, maxNumber) => {\r\n            minNum = minNumber;\r\n            maxNum = maxNumber;\r\n        }\r\n\r\n        this.getColor = props => {\r\n            if (props) {\r\n                return '#' + generateHex(props, startColor.substring(0, 2), endColor.substring(0, 2)) +\r\n                    generateHex(props, startColor.substring(2, 4), endColor.substring(2, 4)) +\r\n                    generateHex(props, startColor.substring(4, 6), endColor.substring(4, 6));\r\n            }\r\n        }\r\n\r\n        const generateHex = (number, start, end) => {\r\n            if (number < minNum) {\r\n                number = minNum;\r\n            } else if (number > maxNum) {\r\n                number = maxNum;\r\n            }\r\n\r\n            let midPoint = maxNum - minNum;\r\n            let startBase = parseInt(start, 16);\r\n            let endBase = parseInt(end, 16);\r\n            let average = (endBase - startBase) / midPoint;\r\n            let finalBase = Math.round(average * (number - minNum) + startBase);\r\n            let balancedFinalBase = finalBase < 16 ? \"0\" + finalBase.toString(16) : finalBase.toString(16);\r\n            return balancedFinalBase;\r\n        }\r\n\r\n        const getHexColor = props => {\r\n            return props.substring(props.length - 6, props.length);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Gradient;"]},"metadata":{},"sourceType":"script"}