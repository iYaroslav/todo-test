{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _color = require('color');\n\nvar _color2 = _interopRequireDefault(_color);\n\nvar _errors = require('./errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Generate n colors with given color stops\n *\n * @param   {Array}  colorArray\n * @param   {Number} n          number of colors that need to generate\n * @returns {Array} array of generated colors in rgb mode\n */\n\n\nfunction gradient(colorArray, n) {\n  var isFullOption = checkParam(colorArray, n); // init 2 arrays for algorithm\n\n  var colorList = [];\n  var fracList = []; // result array for storing data\n\n  var resultArray = []; // simple array of color string\n\n  if (!isFullOption) {\n    var frac = 1 / (colorArray.length - 1);\n    colorArray.forEach(function (colorString, index) {\n      if (index !== colorArray.length - 1) {\n        colorList.push((0, _color2[\"default\"])(colorString));\n        fracList.push(frac);\n      } else {\n        colorList.push((0, _color2[\"default\"])(colorString));\n      }\n    });\n  } else {\n    colorArray.forEach(function (obj, index) {\n      if (index !== colorArray.length - 1) {\n        colorList.push((0, _color2[\"default\"])(obj.color));\n        fracList.push(obj.frac);\n      } else {\n        if (obj.color) {\n          // the last item could be like { color: #ffffff }\n          colorList.push((0, _color2[\"default\"])(obj.color));\n        } else {\n          // and it could also be like '#ffffff'\n          colorList.push((0, _color2[\"default\"])(obj));\n        }\n      }\n    });\n  }\n\n  var assignList = assignNumbers(fracList, n);\n  resultArray = createGradient(colorList, assignList); // convert colors to string version\n\n  resultArray = resultArray.map(function (c) {\n    return c.rgb().toString();\n  });\n  return resultArray;\n}\n/**\n * Explainations:\n * o -> stop color for gradient\n * * -> generated color\n *\n * o * * * | o * * * * | o * * o -> generated color list in char version\n *    4          5          4    -> assigned number of colors need to be generated\n *\n * The last section, the end color should be considered in the generated colors\n *\n * @returns {Array} array of colors in Color(pkg) format, need toString() call\n */\n\n\nfunction createGradient(colorList, assignList) {\n  var result = [];\n  assignList.forEach(function (num, index) {\n    var isLastElement = index === assignList.length - 1;\n    var list = []; // get end point color\n\n    var start = colorList[index];\n    var end = colorList[index + 1]; // if last element, end color should be in the list,\n    // so the num = num - 1\n\n    if (isLastElement) {\n      num = num - 1;\n    }\n\n    var deltaR = (end.red() - start.red()) / num;\n    var deltaG = (end.green() - start.green()) / num;\n    var deltaB = (end.blue() - start.blue()) / num; // generate num colors\n\n    for (var i = 0; i < num; i++) {\n      var R = start.red() + i * deltaR;\n      var G = start.green() + i * deltaG;\n      var B = start.blue() + i * deltaB;\n      list.push(_color2[\"default\"].rgb(R, G, B));\n    } // if last element, end this list with the last color\n\n\n    if (isLastElement) {\n      list.push(end);\n    }\n\n    result = result.concat(list);\n  });\n  return result;\n}\n/**\n * Calculate and optimize the number of each color period\n *\n * Sometimes frac * N might be a fraction\n * So we use this algorithm:\n *\n * 1. Split the number into 2 parts, each part fits in an array:\n * [2, 4, 1, 5]         -> int array\n * [0.2, 0.5, 0.9, 0.3] -> decimal array\n *\n * The left number should be:\n * left = N - sum(intArray)\n *\n * 2. Sort the decimal array from large to small, assign left to\n * the corresponding element in intArray one by one\n * until left === 0\n *\n * 3. There goes your final array!\n *\n * @returns {Array} array of optimized color numbers\n */\n\n\nfunction assignNumbers(fracList, n) {\n  var intArray = [];\n  var decimalArray = []; // assign int part\n\n  fracList.forEach(function (frac, index) {\n    var real = frac * n;\n    var intPart = Math.floor(real);\n    var decimalPart = real - intPart;\n    intArray.push(intPart);\n    decimalArray.push({\n      value: decimalPart,\n      index: index\n    });\n  }); // how many left ?\n\n  var left = n - intArray.reduce(function (a, b) {\n    return a + b;\n  }, 0); // sort O -> o\n\n  decimalArray.sort(function (a, b) {\n    return b.value - a.value;\n  }); // assign the left number regard to the decimal part's value\n  // until nothing left\n\n  for (var i = 0; i < left; i++) {\n    var targetIndex = decimalArray[i].index;\n    intArray[targetIndex] = intArray[targetIndex] + 1;\n  }\n\n  return intArray;\n}\n/**\n * Check param format and throw some errors\n */\n\n\nfunction checkParam(array, n) {\n  // Seriously? Anyone this dumb?\n  if (array.length < 2) {\n    throw _errors.MIN_ARRAY_LENGTH;\n  } // Read the documentation OMG! Of course no frac at the end!\n\n\n  if (array[array.length - 1].frac) {\n    throw _errors.NO_EDN_FRAC;\n  } // You need to see a doctor, like, right now\n\n\n  if (n <= array.length) {\n    throw _errors.COLOR_NUMBER_ERROR;\n  } // if full option mode, sum should be 1\n\n\n  if (typeof array[0] !== 'string') {\n    var fracSum = array.slice(0, array.length - 1).reduce(function (a, b) {\n      return a + b.frac;\n    }, 0);\n\n    if (fracSum < 0.99) {\n      throw _errors.FRAC_SUM_ERROR;\n    }\n  }\n\n  var result = void 0;\n\n  if (typeof array[0] === 'string') {\n    result = false;\n  } else {\n    result = true;\n  }\n\n  return result;\n}\n\nexports[\"default\"] = gradient;","map":{"version":3,"sources":["/Users/maksim/Documents/Worksapce/todo/node_modules/gradient-color/build/index.js"],"names":["Object","defineProperty","exports","value","_color","require","_color2","_interopRequireDefault","_errors","obj","__esModule","gradient","colorArray","n","isFullOption","checkParam","colorList","fracList","resultArray","frac","length","forEach","colorString","index","push","color","assignList","assignNumbers","createGradient","map","c","rgb","toString","result","num","isLastElement","list","start","end","deltaR","red","deltaG","green","deltaB","blue","i","R","G","B","concat","intArray","decimalArray","real","intPart","Math","floor","decimalPart","left","reduce","a","b","sort","targetIndex","array","MIN_ARRAY_LENGTH","NO_EDN_FRAC","COLOR_NUMBER_ERROR","fracSum","slice","FRAC_SUM_ERROR"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _color = require('color');\n\nvar _color2 = _interopRequireDefault(_color);\n\nvar _errors = require('./errors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Generate n colors with given color stops\n *\n * @param   {Array}  colorArray\n * @param   {Number} n          number of colors that need to generate\n * @returns {Array} array of generated colors in rgb mode\n */\n\nfunction gradient(colorArray, n) {\n  var isFullOption = checkParam(colorArray, n);\n\n  // init 2 arrays for algorithm\n  var colorList = [];\n  var fracList = [];\n  // result array for storing data\n  var resultArray = [];\n\n  // simple array of color string\n  if (!isFullOption) {\n    var frac = 1 / (colorArray.length - 1);\n\n    colorArray.forEach(function (colorString, index) {\n      if (index !== colorArray.length - 1) {\n        colorList.push((0, _color2.default)(colorString));\n        fracList.push(frac);\n      } else {\n        colorList.push((0, _color2.default)(colorString));\n      }\n    });\n  } else {\n    colorArray.forEach(function (obj, index) {\n      if (index !== colorArray.length - 1) {\n        colorList.push((0, _color2.default)(obj.color));\n        fracList.push(obj.frac);\n      } else {\n        if (obj.color) {\n          // the last item could be like { color: #ffffff }\n          colorList.push((0, _color2.default)(obj.color));\n        } else {\n          // and it could also be like '#ffffff'\n          colorList.push((0, _color2.default)(obj));\n        }\n      }\n    });\n  }\n\n  var assignList = assignNumbers(fracList, n);\n  resultArray = createGradient(colorList, assignList);\n\n  // convert colors to string version\n  resultArray = resultArray.map(function (c) {\n    return c.rgb().toString();\n  });\n\n  return resultArray;\n}\n\n/**\n * Explainations:\n * o -> stop color for gradient\n * * -> generated color\n *\n * o * * * | o * * * * | o * * o -> generated color list in char version\n *    4          5          4    -> assigned number of colors need to be generated\n *\n * The last section, the end color should be considered in the generated colors\n *\n * @returns {Array} array of colors in Color(pkg) format, need toString() call\n */\n\nfunction createGradient(colorList, assignList) {\n  var result = [];\n\n  assignList.forEach(function (num, index) {\n    var isLastElement = index === assignList.length - 1;\n    var list = [];\n\n    // get end point color\n    var start = colorList[index];\n    var end = colorList[index + 1];\n\n    // if last element, end color should be in the list,\n    // so the num = num - 1\n    if (isLastElement) {\n      num = num - 1;\n    }\n\n    var deltaR = (end.red() - start.red()) / num;\n    var deltaG = (end.green() - start.green()) / num;\n    var deltaB = (end.blue() - start.blue()) / num;\n\n    // generate num colors\n    for (var i = 0; i < num; i++) {\n      var R = start.red() + i * deltaR;\n      var G = start.green() + i * deltaG;\n      var B = start.blue() + i * deltaB;\n\n      list.push(_color2.default.rgb(R, G, B));\n    }\n\n    // if last element, end this list with the last color\n    if (isLastElement) {\n      list.push(end);\n    }\n\n    result = result.concat(list);\n  });\n\n  return result;\n}\n\n/**\n * Calculate and optimize the number of each color period\n *\n * Sometimes frac * N might be a fraction\n * So we use this algorithm:\n *\n * 1. Split the number into 2 parts, each part fits in an array:\n * [2, 4, 1, 5]         -> int array\n * [0.2, 0.5, 0.9, 0.3] -> decimal array\n *\n * The left number should be:\n * left = N - sum(intArray)\n *\n * 2. Sort the decimal array from large to small, assign left to\n * the corresponding element in intArray one by one\n * until left === 0\n *\n * 3. There goes your final array!\n *\n * @returns {Array} array of optimized color numbers\n */\n\nfunction assignNumbers(fracList, n) {\n  var intArray = [];\n  var decimalArray = [];\n\n  // assign int part\n  fracList.forEach(function (frac, index) {\n    var real = frac * n;\n    var intPart = Math.floor(real);\n    var decimalPart = real - intPart;\n\n    intArray.push(intPart);\n    decimalArray.push({\n      value: decimalPart,\n      index: index\n    });\n  });\n\n  // how many left ?\n  var left = n - intArray.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n\n  // sort O -> o\n  decimalArray.sort(function (a, b) {\n    return b.value - a.value;\n  });\n\n  // assign the left number regard to the decimal part's value\n  // until nothing left\n  for (var i = 0; i < left; i++) {\n    var targetIndex = decimalArray[i].index;\n    intArray[targetIndex] = intArray[targetIndex] + 1;\n  }\n\n  return intArray;\n}\n\n/**\n * Check param format and throw some errors\n */\n\nfunction checkParam(array, n) {\n  // Seriously? Anyone this dumb?\n  if (array.length < 2) {\n    throw _errors.MIN_ARRAY_LENGTH;\n  }\n\n  // Read the documentation OMG! Of course no frac at the end!\n  if (array[array.length - 1].frac) {\n    throw _errors.NO_EDN_FRAC;\n  }\n\n  // You need to see a doctor, like, right now\n  if (n <= array.length) {\n    throw _errors.COLOR_NUMBER_ERROR;\n  }\n\n  // if full option mode, sum should be 1\n  if (typeof array[0] !== 'string') {\n    var fracSum = array.slice(0, array.length - 1).reduce(function (a, b) {\n      return a + b.frac;\n    }, 0);\n    if (fracSum < 0.99) {\n      throw _errors.FRAC_SUM_ERROR;\n    }\n  }\n\n  var result = void 0;\n\n  if (typeof array[0] === 'string') {\n    result = false;\n  } else {\n    result = true;\n  }\n\n  return result;\n}\n\nexports.default = gradient;"]},"metadata":{},"sourceType":"script"}